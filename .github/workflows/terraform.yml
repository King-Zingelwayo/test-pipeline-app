name: Terraform CI/CD

on:
  pull_request:
    branches:
      - main
      - master
      - dev
      - qa
      - prod
  push:
    branches:
      - main
      - master
      - dev
      - qa
      - prod
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        type: choice
        options:
          - 'dev'
          - 'qa'
          - 'prod'
      aws_region:
        description: 'AWS Region'
        required: true
        type: string
        default: 'us-east-1'
      tf_state_bucket:
        description: 'Terraform State S3 Bucket'
        required: true
        type: string
      role_arn:
        description: 'AWS Role ARN (overrides default pipeline role)'
        required: false
        type: string
      fail_on_security_issues:
        description: 'Fail pipeline on security/linting issues'
        required: false
        default: 'false'
        type: choice
        options:
          - 'true'
          - 'false'

permissions:
  id-token: write   # Required for OIDC
  contents: read
  pull-requests: write  # Required for PR comments
  issues: write         # Required for PR comments

jobs:
  plan:
    name: Terraform Plan
    runs-on: ubuntu-latest

    env:
      AWS_REGION: ${{ github.event.inputs.aws_region || secrets.AWS_REGION }}
      TF_STATE_BUCKET: ${{ github.event.inputs.tf_state_bucket || secrets.TF_STATE_BUCKET }}

    steps:
      - name: Checkout Code
        uses: actions/checkout@v3

      - name: Set AWS Role and Environment
        id: set-role
        run: |
          # Determine environment from input or branch
          ENV="${{ github.event.inputs.environment }}"
          if [ -z "$ENV" ]; then
            BRANCH="${{ github.ref_name }}"
            case "$BRANCH" in
              main|master) ENV="prod" ;;
              qa) ENV="qa" ;;
              dev) ENV="dev" ;;
              *) ENV="dev" ;;
            esac
          fi
          echo "Environment: $ENV"
          
          # Use input role ARN or default pipeline role ARN
          if [ -n "${{ github.event.inputs.role_arn }}" ]; then
            ROLE_ARN="${{ github.event.inputs.role_arn }}"
            echo "Using input role ARN"
          else
            ROLE_ARN="${{ secrets.PIPELINE_ROLE_ARN }}"
            echo "Using pipeline role ARN"
          fi
          
          echo "ROLE_ARN=$ROLE_ARN" >> $GITHUB_ENV
          echo "ENVIRONMENT=$ENV" >> $GITHUB_ENV
          echo "Selected ROLE_ARN: $ROLE_ARN"
          echo "Selected ENVIRONMENT: $ENV"
          
          if [ -z "$ROLE_ARN" ] || [ "$ROLE_ARN" = "" ]; then
            echo "ERROR: No role ARN configured. Please set PIPELINE_ROLE_ARN secret or provide role_arn input."
            exit 1
          fi

      - name: Configure AWS Credentials via OIDC
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: ${{ env.AWS_REGION }}
          role-to-assume: ${{ env.ROLE_ARN }}
          role-session-name: GitHubActions-${{ github.run_id }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.6.0

      - name: Terraform Init (S3 Backend)
        run: |
          terraform init \
            -backend-config="bucket=${{ env.TF_STATE_BUCKET }}" \
            -backend-config="key=${{ env.ENVIRONMENT }}/terraform.tfstate" \
            -backend-config="region=${{ env.AWS_REGION }}" \
            -input=false

      - name: Run Checkov
        id: checkov
        uses: bridgecrewio/checkov-action@master
        continue-on-error: true
        with:
          directory: .
          framework: terraform

      - name: Setup TFLint
        uses: terraform-linters/setup-tflint@v3
        with:
          tflint_version: latest

      - name: Run TFLint
        id: tflint
        continue-on-error: true
        run: tflint --init && tflint

      - name: Run TFSec
        id: tfsec
        uses: aquasecurity/tfsec-action@v1.0.3
        continue-on-error: true
        with:
          working_directory: .

      - name: Select .tfvars File
        run: |
          # Find first .tfvars file
          TFVARS_FILE=$(find . -name "*.tfvars" -type f | head -1)
          
          if [ -n "$TFVARS_FILE" ]; then
            echo "ENV_FILE=$TFVARS_FILE" >> $GITHUB_ENV
            echo "Using tfvars file: $TFVARS_FILE"
          else
            echo "No .tfvars files found - continuing without variable file"
          fi

      - name: Terraform Plan
        id: plan
        run: |
          set +e
          if [ -n "${{ env.ENV_FILE }}" ]; then
            terraform plan -var-file=${{ env.ENV_FILE }} -no-color -detailed-exitcode > plan_output.txt 2>&1
          else
            terraform plan -no-color -detailed-exitcode > plan_output.txt 2>&1
          fi
          PLAN_EXIT_CODE=$?
          
          # Read plan output
          PLAN_OUTPUT=$(cat plan_output.txt)
          
          # Set outputs
          echo "exit_code=$PLAN_EXIT_CODE" >> $GITHUB_OUTPUT
          echo "PLAN_OUTPUT<<EOF" >> $GITHUB_OUTPUT
          echo "$PLAN_OUTPUT" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          
          # Exit with original code for workflow status
          exit $PLAN_EXIT_CODE

      - name: Comment PR with Plan
        if: always() && github.event_name == 'pull_request'
        uses: actions/github-script@v6
        with:
          script: |
            const plan = `${{ steps.plan.outputs.PLAN_OUTPUT || 'Plan output not available' }}`;
            const planExitCode = '${{ steps.plan.outputs.exit_code }}';
            const checkovStatus = '${{ steps.checkov.outcome }}' === 'success' ? '‚úÖ Passed' : '‚ùå Failed';
            const tflintStatus = '${{ steps.tflint.outcome }}' === 'success' ? '‚úÖ Passed' : '‚ùå Failed';
            const tfsecStatus = '${{ steps.tfsec.outcome }}' === 'success' ? '‚úÖ Passed' : '‚ùå Failed';
            
            let planStatus = '‚ùå Failed';
            if (planExitCode === '0') planStatus = '‚úÖ No changes';
            else if (planExitCode === '2') planStatus = 'üìã Changes detected';
            
            const output = `## ü§ñ Terraform Plan Review Bot
            
            **Environment:** ${{ env.ENVIRONMENT }}
            **AWS Region:** ${{ env.AWS_REGION }}
            **Branch:** ${{ github.ref_name }}
            **Plan Status:** ${planStatus}
            
            ### üîç Security Scan Results
            - **Checkov:** ${checkovStatus}
            - **TFLint:** ${tflintStatus}
            - **TFSec:** ${tfsecStatus}
            
            ### üìã Terraform Plan Output
            <details>
            <summary>Click to view plan details</summary>
            
            \`\`\`terraform
            ${plan}
            \`\`\`
            </details>
            
            ### üöÄ Next Steps
            ${planExitCode === '2' ? '- ‚úÖ Review changes above and merge to apply' : '- ‚ÑπÔ∏è No infrastructure changes detected'}
            - Monitor deployment in GitHub Actions after merge
            
            ---
            *üêò Generated by Elephant TF CI Bot*`;
            
            try {
              // Find existing comment
              const { data: comments } = await github.rest.issues.listComments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
              });
              
              const botComment = comments.find(comment => 
                comment.user.type === 'Bot' && comment.body.includes('ü§ñ Terraform Plan Review Bot')
              );
              
              if (botComment) {
                // Update existing comment
                await github.rest.issues.updateComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  comment_id: botComment.id,
                  body: output
                });
                console.log('Updated existing PR comment');
              } else {
                // Create new comment
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.issue.number,
                  body: output
                });
                console.log('Created new PR comment');
              }
            } catch (error) {
              console.error('Error posting PR comment:', error);
            }

  apply:
    name: Terraform Apply
    needs: plan
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && !startsWith(github.ref_name, 'feature/') && github.event.head_commit.message != null && contains(github.event.head_commit.message, 'Merge pull request')

    env:
      AWS_REGION: ${{ github.event.inputs.aws_region || secrets.AWS_REGION }}
      TF_STATE_BUCKET: ${{ github.event.inputs.tf_state_bucket || secrets.TF_STATE_BUCKET }}

    steps:
      - name: Checkout Code
        uses: actions/checkout@v3

      - name: Set AWS Role and Environment
        id: set-role
        run: |
          # Determine environment from input or branch
          ENV="${{ github.event.inputs.environment }}"
          if [ -z "$ENV" ]; then
            BRANCH="${{ github.ref_name }}"
            case "$BRANCH" in
              main|master) ENV="prod" ;;
              qa) ENV="qa" ;;
              dev) ENV="dev" ;;
              *) ENV="dev" ;;
            esac
          fi
          echo "Environment: $ENV"
          
          # Use input role ARN or default pipeline role ARN
          if [ -n "${{ github.event.inputs.role_arn }}" ]; then
            ROLE_ARN="${{ github.event.inputs.role_arn }}"
            echo "Using input role ARN"
          else
            ROLE_ARN="${{ secrets.PIPELINE_ROLE_ARN }}"
            echo "Using pipeline role ARN"
          fi
          
          echo "ROLE_ARN=$ROLE_ARN" >> $GITHUB_ENV
          echo "ENVIRONMENT=$ENV" >> $GITHUB_ENV
          echo "Selected ROLE_ARN: $ROLE_ARN"
          echo "Selected ENVIRONMENT: $ENV"
          
          if [ -z "$ROLE_ARN" ] || [ "$ROLE_ARN" = "" ]; then
            echo "ERROR: No role ARN configured. Please set PIPELINE_ROLE_ARN secret or provide role_arn input."
            exit 1
          fi

      - name: Configure AWS Credentials via OIDC
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: ${{ env.AWS_REGION }}
          role-to-assume: ${{ env.ROLE_ARN }}
          role-session-name: GitHubActions-${{ github.run_id }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.6.0

      - name: Terraform Init (S3 Backend)
        run: |
          terraform init \
            -backend-config="bucket=${{ env.TF_STATE_BUCKET }}" \
            -backend-config="key=${{ env.ENVIRONMENT }}/terraform.tfstate" \
            -backend-config="region=${{ env.AWS_REGION }}" \
            -input=false

      - name: Select .tfvars File
        run: |
          # Find first .tfvars file
          TFVARS_FILE=$(find . -name "*.tfvars" -type f | head -1)
          
          if [ -n "$TFVARS_FILE" ]; then
            echo "ENV_FILE=$TFVARS_FILE" >> $GITHUB_ENV
            echo "Using tfvars file: $TFVARS_FILE"
          else
            echo "No .tfvars files found - continuing without variable file"
          fi

      - name: Terraform Plan
        run: |
          if [ -n "${{ env.ENV_FILE }}" ]; then
            terraform plan -var-file=${{ env.ENV_FILE }}
          else
            terraform plan
          fi

      - name: Terraform Apply
        run: |
          if [ -n "${{ env.ENV_FILE }}" ]; then
            terraform apply -auto-approve -var-file=${{ env.ENV_FILE }}
          else
            terraform apply -auto-approve
          fi